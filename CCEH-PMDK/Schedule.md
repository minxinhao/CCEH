# Schedule to move directory into DRAM


## Previouse implementation

Reference for Directory and data members in Directory.

``` c++
class CCEH : public Hash {
    private:
	    TOID(struct Directory) dir;
}

struct Directory{
    static const size_t kDefaultDepth = 10;

    TOID_ARRAY(TOID(struct Segment)) segment;	

    int64_t sema = 0;
    size_t capacity;		
    size_t depth;	

    bool suspend();
    bool lock();
    void unlock(void){

    void initDirectory(void)
    void initDirectory(size_t _depth)
}
```

The only update for informations in directory occures during splitting 1 and 2:
1. split operation 1: split a segment of local depth i to i+1 on the global depth equal to or greater than i+1 

CCEH::insert流程图：
``` flow
st=>start: start
op1=>operation: ***通过x哈希值以及当前的directory的global depth，获取segment index***
op2=>operation: ***访问directory存放的segment指针***
op3=>operation: 对segment进行访问控制和判断，获取segment的互斥锁
op4=>operation: 在segment中进行空闲位置查找和插入操作
op5=>operation: 未找到空闲位置，对segemt调用split，生成一个新的segment，并搬迁数据。
cond1=>operation: local depth和global depth相等，进行double resize
    op6=>operation: ***重新分配directory以及segment指针数组***
    op7=>operation: 进行segment数据搬迁
    op8=>operation: 刷写segment数据
    op9=>operation: ***刷写directory***
    op10=>operation: ***更新CCEH的directory指针***
    op11=>operation: 增加被分裂segment local depth并刷写
    op12=>operation: 释放对segment的互斥锁
cond2=>local dept小于global depth，进行一次正常split
    op13=>operation: ***按照MSB的segment index，更新directory的指针数据中所有共享segment 指针***
    op14=>operation: 增加被分裂segment local depth并刷写
    op15=>operation: 释放对segment的互斥锁
e=>end: end
st->op1->op2->op3->op4->op5->cond1
cond1(yes)->op6->op7->op8->op9->op10->op11->op12->e
cond1(no)->cond2
cond2(yes)->op13->op14->op15->e
cond2(no)->e
```
2. resize directory of global depth i to global depth i+1.
``` flow
    st=>start: start
    op1=>operation: ***更新directory共享segment指针部分***
    e=>end: end
    st->op1->e
```

Get操作流程图：
``` flow
    st=>start: start
    op1=>operation: ***通过x哈希值以及当前的directory的global depth，获取segment index***
    op2=>operation: ***访问directory存放的segment指针***
    op3=>operation: 对segment进行访问控制和判断，获取segment的互斥锁
    op4=>operation: 在segment中进行空闲位置查找和插入操作
    e=>end: end
    st->op1->op2->op3->op4->e
```

Recovery操作流程图：
``` flow
    st=>start: start
    op1=>operation: ***访问directory的global depth g和其中的每个一个segment指针***
    op2=>operation: 对每一个segmet x的local depth i，对后续2^(g-i)的segment进行判断
    cond1=>condition: ***如果后续segment y的local depth不为i***
    op3=>operation: ***更新directory指针数组中y的指针指向x***
    e=>end: end
    st->op1->op2->cond1
    cond1(yes)->op3->e
    cond1(no)->e
```

## Transplant

### Version 1.0

#### Design

Transplant single-thread , in-place and no-placement policy(linear probe or cuckoo placement) version

* Directory exists in both PM and Memory
* The directory in the memory is used as a cache, and the update of the directory first occurs in the memory part, and then periodically synchronized to the PM,
  * Only when the directory performs double resize, the global depth and segment arrays saved in the directory are synchronized to the PM,
  * When a normal segment split occurs, update the first pointer of the segment array in the diretory in the PM (because the data of the subsequent segment will be synchronized according to the information of the first segment during recovery, so inconsistencies can be detected)


#### Implementation Details

##### Changes In CCEH

Add a new data member mem_dir as the directory cache.

``` c++
struct CCEH{
    ...
    private:
	TOID(struct Directory) dir;
    struct Directory * mem_dir; // add directory cache
}
```

The CCEH interface to be modified includes:
* initCCEH: Add the allocation of memory for the directory, and copy the PM content to the directory part
* Insert：
  * modified to use the directory cache in memory
  * modified the split update logic of directory
* insertOnly and Delete are not given't in original version,so version 1.0 ignore them too
* Get: modified to use the directory cache in memory
* FindAnyway: modified to use the directory cache in memory
* Utilization: modified to use the directory cache in memory
* Capacity: modified to use the directory cache in memory
* Recovery
  * Add handling of inconsistencies caused by only synchronizing the first segment pointer during normal split
  * Add the function of restoring the directory in memory according to PM directory

Among them, the specific analysis of the update operation with simplified normal split is as follows:
Originally, every time the normal split of segment x was performed, all pointers to that segment of directroy had to be updated. According to the operation logic of CCEH, when there is a share for the segment, all access to the segment will only be accessed through the first matching item (MSB).So every time you perform a normal split on a segment x, you only need to update the two new segment pointers (or one) generated by the split to two (or one) segment array bits.
During recovery, the segment array is accessed sequentially.
The original judgment and detection required include: for the segment x with global depth g and local depth of i, the subsequent 2^(g-i) segments of any segment y whose local depth is not i will be updated with pointer to x.
> Why not compare PMEMoid directly, x and y should be the same segment?

Now because of the omission of the normal split modification, when restoring, for the segment x with global depth g and local depth i, also check the segment y whose local depth is not i in the subsequent 2^(g-i) segments, and update the point The pointer of y is x.

The help functions that need to be added include:

* Read directory from PM to memory cache mem_dir
* Function to flush memory cache mem_dir to directory in PM
  * To insure the failure-consistency in flushing, use a temp PM directory as inner-state.
  * This brings an additional copy operation.

##### Changes In Directory

No need to change struct Directory.

##### No Changes In Segment
